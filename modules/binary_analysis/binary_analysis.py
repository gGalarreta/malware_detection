from raw_analysis import raw_analysis
from dll_analysis import dll_analysis
from opcode_analysis import opcode_analysis
import glob
import pefile
import pydasm
import os

class BinaryAnalysis():

  def __init__(self):
    self.malwares_directory = ""
    self.bening_directory = ""
    self.ouput_malwares_directory = ""
    self.ouput_bening_directory = ""

    self.raw = False
    self.dll = False
    self.opcodes = False

    self.features_directory = ""

    self.data_malware_groups = []
    self.data_bening_groups = []
    self.data_percentage = 0

    self.raw_analyzer = raw_analysis.Raw()
    self.dll_analyzer = dll_analysis.Dll()
    self.opcodes_analyzer = opcode_analysis.Opcode()


  def set_malware_directory(self, malware_root):
    self.malwares_directory = malware_root

  def set_bening_directory(self, bening_root):
    self.bening_directory = bening_directory

  def disassemble(self, *args):
    self.dissemble_settings()    
    if self.malwares_directory == "" :
      print "You must set the directory of malware samples"
    else :
      if args :
        print "This could be take some minutes"
        for arg in args:
          if "raw" == arg.lower() : self.raw = True
          if "dll" == arg.lower() : self.dll = True
          if "opcodes" == arg.lower() : self.opcodes = True
        self.disassemble_malwares()
        self.disassemble_benings()
      else :
        print "You must set the pe files structures as a arguments\nValid Values: raw,dll,opcodes"

  def disassemble_malwares(self):
    self.ouput_malwares_directory = os.getcwd() + "/raw_final_dataset"
    self.create_directory(self.ouput_malwares_directory, True)
    for folder in os.listdir(self.malwares_directory):
      final_dataset_classes_directory = self.ouput_malwares_directory + "/" + folder
      self.create_directory(final_dataset_classes_directory, False)
      raw_output_directoy, dll_output_directory, opcode_output_directory = self.set_directories(final_dataset_classes_directory)
      samples_directory = self.malwares_directory + "/" + folder
      files = os.listdir(samples_directory)
      number_of_samples = 0
      for file in files:
        pe =  pefile.PE(samples_directory + "/" + file)
        raw_filename = raw_output_directoy + "/" + file + ".txt"
        self.raw_analyzer.disassemble(pe, raw_filename)
        dll_filename = dll_output_directory + "/" + file + ".txt"
        self.dll_analyzer.disassemble(pe, dll_filename)
        opcode_filename = opcode_output_directory + "/" + file + ".txt"
        self.opcodes_analyzer.disassemble(pe, opcode_filename)
        number_of_samples +=1
      self.add_malware_group_size(number_of_samples)
    return True

  def add_malware_group_size(self, size):
    self.data_malware_groups.append(size)

  def dissemble_settings(self):
    self.raw_analyzer.set_labels()

  def disassemble_benings(self):
    return True
    
  def extract_features(self):
    self.features_directory = os.getcwd() + "/features"
    print "Base features are stored in " + self.features_directory
    for folder in os.listdir(self.ouput_malwares_directory):
      raw_feature_directory, dll_feature_directory, opcode_feature_directory = self.set_directories(self.features_directory + "/" + folder)
      #raw_directory = self.ouput_malwares_directory + "/" + folder + "/raw"
      dll_input_directory = self.ouput_malwares_directory + "/" + folder + "/dll"
      #opcode_directory = self.ouput_malwares_directory + "/" + folder + "/opcode"
      self.dll_analyzer.extract_features(dll_input_directory, dll_feature_directory + "/base.txt")


    # dll unicos en un archivo
    # n grams opcodes unicos en un archivo
    # raw atributos en un archivo
    # cluster de dll
    # clusterr de opcode
    # scaler de raw
    # cluster de raw
    # reduccion de raw, dll y opcode con rfe y otro
    # archivos finales de cada atributo
    return True

  def set_directories(self, path):
    raw_directory = path + "/raw"
    dll_directory = path + "/dll"
    opcode_directory = path + "/opcode"
    self.create_directory(raw_directory, False)
    self.create_directory(dll_directory, False)
    self.create_directory(opcode_directory, False)
    return raw_directory, dll_directory, opcode_directory

  def vectorize(self):
    # se construye los vectores de caracteristicas para cada muestra
    # usando los archivos de salida del desensamblado y los detalles
    # se obtiene archivos con los datos en formato adecuado
    return True

  def algorithm_model(self):
    # se solicita el porcentaje de datos a utilizar
    # se carga la data de los archivos obtenidos de la vectorizacion
    # se entrena el modelo y se obtienen los archivos necesarios para la prediccion
    return True

  def prediction(self):
    # se usa el porcentaje de test
    # se dadn resultados
    return True

  def create_directory(self, directory, is_root):
    if is_root:
      print "Samples are stored in " + directory
    if not os.path.exists(directory):
      os.makedirs(directory)

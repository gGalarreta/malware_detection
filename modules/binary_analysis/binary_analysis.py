from raw_analysis import raw_analysis
from dll_analysis import dll_analysis
from opcode_analysis import opcode_analysis
from k_means import k_means
from shutil import copyfile
import glob
import pefile
import pydasm
import os

class BinaryAnalysis():

  def __init__(self):
    self.malwares_directory = ""
    self.bening_directory = ""
    self.ouput_bening_directory = ""

    self.raw = False
    self.dll = False
    self.opcodes = False

    self.extension = ".txt"
    self.raw_name = "raw"
    self.dll_name = "dll"
    self.opcodes_name = "opcode"
    self.feature_name = "feature" + self.extension
    self.features_directory = os.getcwd() + "/features"
    
    self.raw_feature_vector_name = self.features_directory + "/feature_vector_raw" + self.extension
    self.dll_feature_vector_name = self.features_directory + "/feature_vector_dll" + self.extension
    self.opcode_feature_vector_name = self.features_directory + "/feature_vector_opcode" + self.extension

    self.index_files_name = "index" + self.extension
    self.raw_final_dataset_directory = os.getcwd() + "/raw_final_dataset"
    self.matrix_file_name = self.features_directory + "/matrix_features" + self.extension
    self.train_data_set_directory = os.getcwd() + "/train_data_set"
    self.test_data_set_directory = os.getcwd() + "/test_data_set"
    self.rules_directory = os.getcwd() + "/rules/rules" + self.extension

    self.data_malware_groups = []
    self.data_bening_groups = []
    self.data_percentage = 0
    #tomar en cuenta
    self.limit_good_sample = 1
    self.train_percentaje = 0.9


    self.raw_analyzer = raw_analysis.Raw()
    self.dll_analyzer = dll_analysis.Dll()
    self.opcodes_analyzer = opcode_analysis.Opcode()


  def set_malware_directory(self, malware_root):
    self.malwares_directory = malware_root

  def set_bening_directory(self, bening_root):
    self.bening_directory = bening_directory

  def disassemble(self, *args):
    self.dissemble_settings()    
    if self.malwares_directory == "" :
      print "You must set the directory of malware samples"
    else :
      if args :
        print "This could be take some minutes"
        for arg in args:
          if self.raw_name == arg.lower() : self.raw = True
          if self.dll_name == arg.lower() : self.dll = True
          if self.opcodes_name == arg.lower() : self.opcodes = True
        self.disassemble_malwares()
        self.disassemble_benings()
      else :
        print "You must set the pe files structures as a arguments\nValid Values: raw,dll,opcodes"

  def disassemble_malwares(self):
    self.create_directory(self.raw_final_dataset_directory, True)
    
    index_classes = []
    for folder in os.listdir(self.malwares_directory):
      final_dataset_classes_directory = self.raw_final_dataset_directory + "/" + folder
      self.create_directory(final_dataset_classes_directory, False)
      raw_output_directoy, dll_output_directory, opcode_output_directory = self.set_directories(final_dataset_classes_directory)

      samples_directory = self.malwares_directory + "/" + folder
      files = os.listdir(samples_directory)
      number_of_samples = 0
      index_files = []

      for file in files:
        try:
          pe =  pefile.PE(samples_directory + "/" + file)
          if self.raw:
            raw_filename = raw_output_directoy + "/" + file + self.extension
            self.raw_analyzer.disassemble(pe, raw_filename)
          if self.dll:
            dll_filename = dll_output_directory + "/" + file + self.extension
            self.dll_analyzer.disassemble(pe, dll_filename)
          if self.opcodes:
            opcode_filename = opcode_output_directory + "/" + file + self.extension
            self.opcodes_analyzer.disassemble(pe, opcode_filename)

          number_of_samples +=1
          index_files = index_files + [file]
        except Exception as e:
          print e
      self.add_malware_group_size(number_of_samples)
      self.write_file(final_dataset_classes_directory + "/" + self.index_files_name, index_files)
      index_classes = index_classes + [folder]
      self.write_file(self.raw_final_dataset_directory + "/" + self.index_files_name, index_classes)

  def add_malware_group_size(self, size):
    self.data_malware_groups.append(size)

  def dissemble_settings(self):
    self.raw_analyzer.set_labels()

  def disassemble_benings(self):
    return True

  def get_train_test_data(self, train_percentaje):
    message = False
    self.create_directory(self.train_data_set_directory, message)
    self.create_directory(self.test_data_set_directory, message)
    self.train_percentaje = train_percentaje
    for folder in os.listdir(self.raw_final_dataset_directory):
      if folder != self.index_files_name:
        index_file = self.raw_final_dataset_directory + "/" + folder + "/" + self.index_files_name
        list_of_files = self.read_file(index_file)
        number_of_train_files = (train_percentaje * len(list_of_files))/100
        output_directory = ""
        self.create_directory(self.train_data_set_directory + "/" + folder + "/" + self.dll_name, message)
        self.create_directory(self.train_data_set_directory + "/" + folder + "/" + self.opcodes_name, message)
        self.create_directory(self.test_data_set_directory + "/" + folder + "/" + self.dll_name, message)
        self.create_directory(self.test_data_set_directory + "/" + folder + "/" + self.opcodes_name, message)
        for index, file in enumerate(list_of_files):
          if index < number_of_train_files:
            output_directory = self.train_data_set_directory + "/" + folder
          else:
            output_directory = self.test_data_set_directory + "/" + folder
          copyfile(self.raw_final_dataset_directory + "/" + folder + "/" + self.dll_name + "/" + file + self.extension, output_directory + "/" + self.dll_name + "/" + file + self.extension)
          copyfile(self.raw_final_dataset_directory + "/" + folder + "/" + self.opcodes_name + "/" + file + self.extension, output_directory + "/" + self.opcodes_name + "/" + file + self.extension)
    
  def extract_features(self):
    cluster_settings = self.set_cluster_settings()
    self.get_top_features(cluster_settings)

  def get_top_features_through_rules(self):
    rules = self.get_rules()
    message = False
    self.create_directory(self.features_directory, message)
    for index, rule in enumerate(rules):
      self.create_directory(self.features_directory + "/rule_" + str(index), message)
      self.get_top_features2(rule, index)

  def get_top_features2(self, rule_settings, rule_number):
    for folder in os.listdir(self.train_data_set_directory):
      raw_feature_directory, dll_feature_directory, opcode_feature_directory = self.set_directories(self.features_directory + "/rule_" + str(rule_number) + "/" + folder)
      try:
        if self.dll:
          dll_input_directory = self.train_data_set_directory + "/" + folder + "/" + self.dll_name
          dll_output_directory = dll_feature_directory + "/" + self.feature_name
          self.dll_analyzer.extract_features(dll_input_directory, dll_output_directory, rule_settings)
        if self.opcodes:
          opcode_input_directory = self.train_data_set_directory + "/" + folder + "/" + self.opcodes_name
          opcode_output_directory = opcode_feature_directory + "/" + self.feature_name
          self.opcodes_analyzer.extract_features(opcode_input_directory, opcode_output_directory, rule_settings)
      except Exception as e:
        print e


  def get_rules(self):
    lines = self.read_file(self.rules_directory)
    rules_labels = lines[0].split(",")
    rules = []
    lines.pop(0)
    for line in lines:
      rules_dicc = {}
      for index,value in enumerate(line.split(",")):
        label = rules_labels[index]
        rules_dicc[label] = value
      rules.append(rules_dicc)
    return rules

  def get_top_features(self, cluster_settings):
    print "Base features are stored in " + self.features_directory
    self.create_directory(self.features_directory, False)
    for folder in os.listdir(self.raw_final_dataset_directory):
      if folder != self.index_files_name :
        raw_feature_directory, dll_feature_directory, opcode_feature_directory = self.set_directories(self.features_directory + "/" + folder)
        
        #if self.raw:
        #raw_directory = self.raw_final_dataset_directory + "/" + folder + "/raw"
        try:
          if self.dll:
            dll_input_directory = self.raw_final_dataset_directory + "/" + folder + "/" + self.dll_name
            self.dll_analyzer.extract_features(dll_input_directory, dll_feature_directory + "/" + self.feature_name, cluster_settings)
          if self.opcodes:
            opcode_input_directory = self.raw_final_dataset_directory + "/" + folder + "/" + self.opcodes_name
            self.opcodes_analyzer.extract_features(opcode_input_directory, opcode_feature_directory + "/" + self.feature_name, cluster_settings)
        except Exception as e:
          print e

  def set_directories(self, path):
    raw_directory = path + "/" + self.raw_name
    dll_directory = path + "/" + self.dll_name
    opcode_directory = path + "/" + self.opcodes_name
    message = False
    if self.raw:
      self.create_directory(raw_directory, message)
    if self.dll:
      self.create_directory(dll_directory, message)
    if self.opcodes:
      self.create_directory(opcode_directory, message)
    return raw_directory, dll_directory, opcode_directory


  def vectorize(self):
    self.feature_vector()
    self.vectorize_samples()

  def feature_vector(self):
    raw_features, dll_features, opcodes_features = self.get_all_features()
    raw_vector, dll_vector, opcode_vector = self.convert_lists_to_vector(raw_features, dll_features, opcodes_features)
    self.write_file(self.raw_feature_vector_name, raw_vector)
    self.write_file(self.dll_feature_vector_name, dll_vector)
    self.write_file(self.opcode_feature_vector_name, opcode_vector)

  def vectorize_samples(self):
    matrix_file = open(self.matrix_file_name, "w")
    for folder in os.listdir(self.raw_final_dataset_directory):
      if folder != self.index_files_name :
        name_base = self.raw_final_dataset_directory + "/" + folder + "/"
        index_file = name_base + self.index_files_name
        files_in_folder = self.read_file(index_file)
        #raw_feature_vector = self.read_file(self.raw_feature_vector_name)
        dll_feature_vector = self.read_file(self.dll_feature_vector_name)
        opcode_feature_vector = self.read_file(self.opcode_feature_vector_name)
        for file in files_in_folder:
          raw_vector = []
          dll_binary_vector = []
          opcodes_binary_vector = []
          if self.raw:
            return True
          if self.dll:
            dll_attributes = self.read_file(name_base + self.dll_name + "/" + file + self.extension)
            dll_binary_vector = self.get_binary_vector(dll_attributes, dll_feature_vector)
          if self.opcodes:
            opcodes_attributes = self.read_file(name_base + self.opcodes_name + "/" + file + self.extension)
            opcodes_binary_vector = self.get_binary_vector(self.opcodes_analyzer.ngrams(opcodes_attributes), opcode_feature_vector)
          sample_vector = raw_vector + dll_binary_vector + opcodes_binary_vector
          if self.valid_sample_vector(sample_vector):
            sample_vector = self.add_identifie_features(sample_vector, file, folder)
            for item in sample_vector:
              matrix_file.write(str(item))
              matrix_file.write(",")
            matrix_file.write("\n")
    matrix_file.close()

  def get_binary_vector(self, attributes, vector):
    #1 the sample has the feature 
    #0 the sample has not the feature
    output_vector = []
    for feature in vector:
      output_vector = output_vector + [int(feature in attributes)]
    return output_vector

  def valid_sample_vector(self, vector):
    percentage_of_zeros = round(vector.count(0) / float(len(vector)), 2)
    return percentage_of_zeros < self.limit_good_sample

  def add_identifie_features(self, vector, file_name, folder_name):
    #virus_xxx_yyy_zzz,1,0,0,1..1,1,class_name
    return [file_name.lower()] + vector + [folder_name.lower()]

  def get_all_features(self):
    raw_features = []
    dll_features = []
    opcodes_features = []
    for folder in os.listdir(self.features_directory):
      if self.raw:
        raw_directory = self.features_directory + "/" + folder + "/" + self.raw_name + "/" + self.feature_name
      if self.dll:
        dll_directory = self.features_directory + "/" + folder + "/" + self.dll_name + "/" + self.feature_name
        dll_features = dll_features  + self.read_file(dll_directory)
      if self.opcodes:
        opcodes_directory = self.features_directory + "/" + folder + "/" + self.opcodes_name + "/" + self.feature_name
        opcodes_features = opcodes_features + self.read_file(opcodes_directory)
    return raw_features, dll_features, opcodes_features

  def convert_lists_to_vector(self, raw_data_list, dll_data_list, opcode_data_list):
    raw_features = []
    dll_features = []
    opcodes_features = []
    if self.raw:
      True
    if self.dll:
      dll_features =list(set(dll_data_list))
    if self.opcodes:
      opcodes_features = list(set(opcode_data_list))
    return raw_features,dll_features,opcodes_features

  def algorithm_model(self):
    # se solicita el porcentaje de datos a utilizar
    # se carga la data de los archivos obtenidos de la vectorizacion
    # se entrena el modelo y se obtienen los archivos necesarios para la prediccion
    return True

  def prediction(self):
    # se usa el porcentaje de test
    # se dadn resultados
    return True

  def create_directory(self, directory, message):
    if message:
      print "Samples are stored in " + directory
    if not os.path.exists(directory):
      os.makedirs(directory)

  def set_cluster_settings(self):
    #tener en cuenta el tamanho de los datos para setear el rango del cluster
    cluster_settings = {}
    cluster_settings["number_top_words"] = 20
    cluster_settings["lower_limit"] = 6
    cluster_settings["upper_limit"] = 10
    return cluster_settings

  def read_file(self,file_name):
    lines = [line.rstrip('\n') for line in open(file_name)]
    return lines

  def write_file(self, output_file, data_list):
    file = open(output_file, "w")
    for item in data_list:
      file.write(item)
      file.write("\n")
    file.close()

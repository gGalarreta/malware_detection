from raw_analysis import raw_analysis
from dll_analysis import dll_analysis
from opcode_analysis import opcode_analysis
from k_means import k_means
import glob
import pefile
import pydasm
import os

class BinaryAnalysis():

  def __init__(self):
    self.malwares_directory = ""
    self.bening_directory = ""
    self.ouput_malwares_directory = ""
    self.ouput_bening_directory = ""

    self.raw = False
    self.dll = False
    self.opcodes = False

    self.raw_name = "raw"
    self.dll_name = "dll"
    self.opcodes_name = "opcode"
    self.feature_name = "feature.txt"
    self.features_directory = os.getcwd() + "/features"
    self.raw_feature_vector_name = "feature_vector_raw.txt"
    self.dll_feature_vector_name = "feature_vector_dll.txt"
    self.opcode_feature_vector_name = "feature_vector_opcode.txt"
    self.index_files_name = "index.txt"
    self.ouput_malwares_directory = os.getcwd() + "/raw_final_dataset"


    self.data_malware_groups = []
    self.data_bening_groups = []
    self.data_percentage = 0

    self.raw_analyzer = raw_analysis.Raw()
    self.dll_analyzer = dll_analysis.Dll()
    self.opcodes_analyzer = opcode_analysis.Opcode()
    self.cluster_classifier = k_means.Kmeans()


  def set_malware_directory(self, malware_root):
    self.malwares_directory = malware_root

  def set_bening_directory(self, bening_root):
    self.bening_directory = bening_directory

  def disassemble(self, *args):
    self.dissemble_settings()    
    if self.malwares_directory == "" :
      print "You must set the directory of malware samples"
    else :
      if args :
        print "This could be take some minutes"
        for arg in args:
          if self.raw_name == arg.lower() : self.raw = True
          if self.dll_name == arg.lower() : self.dll = True
          if self.opcodes_name == arg.lower() : self.opcodes = True
        self.disassemble_malwares()
        self.disassemble_benings()
      else :
        print "You must set the pe files structures as a arguments\nValid Values: raw,dll,opcodes"

  def disassemble_malwares(self):
    self.create_directory(self.ouput_malwares_directory, True)
    
    index_classes = []
    for folder in os.listdir(self.malwares_directory):
      final_dataset_classes_directory = self.ouput_malwares_directory + "/" + folder
      self.create_directory(final_dataset_classes_directory, False)
      raw_output_directoy, dll_output_directory, opcode_output_directory = self.set_directories(final_dataset_classes_directory)

      samples_directory = self.malwares_directory + "/" + folder
      files = os.listdir(samples_directory)
      number_of_samples = 0
      index_files = []

      for file in files:
        pe =  pefile.PE(samples_directory + "/" + file)
        
        if self.raw:
          raw_filename = raw_output_directoy + "/" + file + ".txt"
          self.raw_analyzer.disassemble(pe, raw_filename)
        if self.dll:
          dll_filename = dll_output_directory + "/" + file + ".txt"
          self.dll_analyzer.disassemble(pe, dll_filename)
        if self.opcodes:
          opcode_filename = opcode_output_directory + "/" + file + ".txt"
          self.opcodes_analyzer.disassemble(pe, opcode_filename)

        number_of_samples +=1
        index_files = index_files + [file]
      self.add_malware_group_size(number_of_samples)
      self.write_file(final_dataset_classes_directory + "/" + self.index_files_name, index_files)
      index_classes = index_classes + [folder]
      self.write_file(self.ouput_malwares_directory + "/" + self.index_files_name, index_classes)
    return True

  def add_malware_group_size(self, size):
    self.data_malware_groups.append(size)

  def dissemble_settings(self):
    self.raw_analyzer.set_labels()

  def disassemble_benings(self):
    return True
    
  def extract_features(self):
    self.set_cluster_settings()
    self.get_top_features()

  def get_top_features(self):
    print "Base features are stored in " + self.features_directory
    for folder in os.listdir(self.ouput_malwares_directory):
      raw_feature_directory, dll_feature_directory, opcode_feature_directory = self.set_directories(self.features_directory + "/" + folder)
      
      #if self.raw:
      #raw_directory = self.ouput_malwares_directory + "/" + folder + "/raw"

      if self.dll:
        dll_input_directory = self.ouput_malwares_directory + "/" + folder + "/" + self.dll_name
        self.dll_analyzer.extract_features(self.cluster_classifier, dll_input_directory, dll_feature_directory + "/" + self.feature_name)
      if self.opcodes:
        opcode_input_directory = self.ouput_malwares_directory + "/" + folder + "/" + self.opcodes_name
        self.opcodes_analyzer.extract_features(self.cluster_classifier, opcode_input_directory, opcode_feature_directory + "/" + self.feature_name)

  def set_directories(self, path):
    raw_directory = path + "/" + self.raw_name
    dll_directory = path + "/" + self.dll_name
    opcode_directory = path + "/" + self.opcodes_name
    message = False
    if self.raw:
      self.create_directory(raw_directory, message)
    if self.dll:
      self.create_directory(dll_directory, message)
    if self.opcodes:
      self.create_directory(opcode_directory, message)
    return raw_directory, dll_directory, opcode_directory


  def vectorize(self):
    self.feature_vector()
    self.vectorize_samples()

  def feature_vector(self):
    raw_features, dll_features, opcodes_features = self.get_all_features()
    raw_vector, dll_vector, opcode_vector = self.convert_lists_to_vector(raw_features, dll_features, opcodes_features)
    self.write_file(self.features_directory + "/" + self.raw_feature_vector_name, raw_vector)
    self.write_file(self.features_directory + "/" + self.dll_feature_vector_name, dll_vector)
    self.write_file(self.features_directory + "/" + self.opcode_feature_vector_name, opcode_vector)

  def vectorize_samples(self):
    # CORRER TODOS LOS PROCESOS como si fuera la parte final
    # aantes ->> debo guardar todos los nombres de los archivos que leo por clase
    # recorro raw final dataset
    # recorro el archivo de nombres por clase
    # obtengo el nombre y extraigo su dll, opcode y su raw
    # comparo con los archivos de vectores
    # construyo vector binario

    #para dll es 1 o 0, para opcode 1 o 0 n gramas

    # agregar el nombre la clase al final


  def get_all_features(self):
    raw_features = []
    dll_features = []
    opcodes_features = []
    for folder in os.listdir(self.features_directory):
      if self.raw:
        raw_directory = self.features_directory + "/" + folder + "/" + self.raw_name + "/" + self.feature_name
      if self.dll:
        dll_directory = self.features_directory + "/" + folder + "/" + self.dll_name + "/" + self.feature_name
        dll_features = dll_features  + self.read_file(dll_directory)
      if self.opcodes:
        opcodes_directory = self.features_directory + "/" + folder + "/" + self.opcodes_name + "/" + self.feature_name
        opcodes_features = opcodes_features + self.read_file(opcodes_directory)
    return raw_features, dll_features, opcodes_features

  def convert_lists_to_vector(self, raw_data_list, dll_data_list, opcode_data_list):
    raw_features = []
    dll_features = []
    opcodes_features = []
    if self.raw:
      True
    if self.dll:
      dll_features =list(set(dll_data_list))
    if self.opcodes:
      opcodes_features = list(set(opcode_data_list))
    return raw_features,dll_features,opcodes_features

  def algorithm_model(self):
    # se solicita el porcentaje de datos a utilizar
    # se carga la data de los archivos obtenidos de la vectorizacion
    # se entrena el modelo y se obtienen los archivos necesarios para la prediccion
    return True

  def prediction(self):
    # se usa el porcentaje de test
    # se dadn resultados
    return True

  def create_directory(self, directory, is_root):
    if is_root:
      print "Samples are stored in " + directory
    if not os.path.exists(directory):
      os.makedirs(directory)

  def set_cluster_settings(self):
    #tener en cuenta el tamanho de los datos para setear el rango del cluster
    self.cluster_classifier.set_number_top_words(20)
    self.cluster_classifier.set_cluster_range(2,6)

  def read_file(self,file_name):
    lines = [line.rstrip('\n') for line in open(file_name)]
    return lines

  def write_file(self, output_file, data_list):
    file = open(output_file, "w")
    for item in data_list:
      file.write(item)
      file.write("\n")
    file.close()

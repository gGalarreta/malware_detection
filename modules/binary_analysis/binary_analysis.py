class BinaryAnalysis():

  def __init__(self):
    self.malwares_directory = ""
    self.bening_directory = ""
    self.ouput_malwares_directory = ""
    self.ouput_bening_directory = ""

    self.raw = False
    self.dll = False
    self.opcodes = False

    self.data_malware_groups = []
    self.data_bening_groups = []
    self.data_percentage = 0

    # iniciar objeto message
    # iniciar objetos raw, dll y opcode

  def set_malware_directory(self, malware_root):
    self.malwares_directory = malware_root

  def set_bening_directory(self, bening_root):
    self.bening_directory = bening_directory

  def disassemble(self, *args):
    if args :
      print "This could be take some minutes"
      for arg in args:
        if "raw" == arg.lower() : self.raw = True
        if "dll" == arg.lower() : self.dll = True
        if "opcodes" == arg.lower() : self.opcodes = True
        # se extrae todo
        # yo defino directorios de salida 
        # contabilizar 
    else :
      print option_blcks_extract_feature_advice

  def extract_features(self):
    # clase raw, dll y opcodes hacen todos sus procesos 
    # se obtiene archivos con detalles utiles para vectorizar

  def vectorize(self):
    # se construye los vectores de caracteristicas para cada muestra
    # usando los archivos de salida del desensamblado y los detalles
    # se obtiene archivos con los datos en formato adecuado

  def algorithm_model(self):
    # se solicita el porcentaje de datos a utilizar
    # se carga la data de los archivos obtenidos de la vectorizacion
    # se entrena el modelo y se obtienen los archivos necesarios para la prediccion

  def prediction(self):
    # se usa el porcentaje de test
    # se dadn resultados









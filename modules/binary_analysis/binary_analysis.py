class BinaryAnalysis():

  def __init__(self):
    self.malwares_directory = ""
    self.bening_directory = ""
    self.ouput_malwares_directory = ""
    self.ouput_bening_directory = ""

    self.raw = False
    self.dll = False
    self.opcodes = False

    self.data_malware_groups = []
    self.data_bening_groups = []
    self.data_percentage = 0

    # iniciar objeto message
    # iniciar objetos raw, dll y opcode

  def set_malware_directory(self, malware_root):
    self.malwares_directory = malware_root

  def set_bening_directory(self, bening_root):
    self.bening_directory = bening_directory

  def disassemble(self, *args):
    if malwares_directory == "" :
      print "You must set the directory of malware samples"
    else :
      if args :
        print "This could be take some minutes"
        for arg in args:
          if "raw" == arg.lower() : self.raw = True
          if "dll" == arg.lower() : self.dll = True
          if "opcodes" == arg.lower() : self.opcodes = True
          self.disassemble_malwares()
          self.disassemble_benings()
      else :
        print "You must set the pe files structures as a arguments\nValid Values: raw,dll,opcodes"

  def disassemble_malwares(self):
    # leer carpetas grandes
    # contar grupos y construir mismas carpetas grandes
    # iterar cada muestra dentro de cada carpeta y obtener datos segun lo q se pida: raw, dll y opcode
    # creo archivos de datos
    # contabilizo
    return True

  def disassemble_benings(self):
    return True
    
  def extract_features(self):
    # clase raw, dll y opcodes hacen todos sus procesos 
    # se obtiene archivos con detalles utiles para vectorizar
    return True

  def vectorize(self):
    # se construye los vectores de caracteristicas para cada muestra
    # usando los archivos de salida del desensamblado y los detalles
    # se obtiene archivos con los datos en formato adecuado
    return True

  def algorithm_model(self):
    # se solicita el porcentaje de datos a utilizar
    # se carga la data de los archivos obtenidos de la vectorizacion
    # se entrena el modelo y se obtienen los archivos necesarios para la prediccion
    return True

  def prediction(self):
    # se usa el porcentaje de test
    # se dadn resultados
    return True









from keras.preprocessing import sequence
from keras.models import Sequential
from keras.layers import Dense, Embedding
from keras.layers import LSTM
from scipy.sparse import *
from collections import defaultdict
import numpy as np
import os


class RnnLstm():

  def __init__(self):
    self.x_train = None
    self.y_train = None
    self.x_test = None
    self.y_test = None
    self.max_features = 500000
    self.max_len = 20
    self.model = Sequential()
    self.output_dim = 128
    self.dropout = 0.2
    self.recurrent_dropout = 0.2
    self.number_classes = 7
    self.activation = 'softmax'
    self.batch_size = 32
    self.epochs = 2
    self.score = None
    self.acc = None
    self.train_data_set_directory = None
    self.test_data_set_directory = None
    self.classes_directory = None
    self.unique_opcodes = None
    self.cols = None
    self.rows = None

  def set_max_features(self, value):
    self.max_features = value

  def set_max_len(self, value):
    self.max_len = value

  def set_output_dim(self, value):
    self.output_dim = value

  def set_number_classes(self, value):
    self.number_classes = value

  def set_batch_size(self, value):
    self.batch_size = value

  def set_epochs(self, value):
    self.epochs = value

  def set_train_data_set_directory(self, value):
    self.train_data_set_directory = value

  def set_test_data_set_directory(self, value):
    self.test_data_set_directory = value

  def set_classes_directory(self, value):
    self.classes_directory = value

  def build(self):
    self.set_classes()
    self.get_direccionary()
    self.x_train, self.y_train = self.load(self.train_data_set_directory)
    self.x_test, self.y_test = self.load(self.test_data_set_directory)
    #self.max_features = len(self.x_train)*self.cols
    self.model.add(Embedding(self.max_features, self.output_dim))
    self.model.add(LSTM(self.output_dim, dropout = self.dropout, recurrent_dropout = self.recurrent_dropout))
    self.model.add(Dense(self.number_classes, activation = self.activation))
    self.model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
    self.model.summary()

  def train(self):
    self.x_train = np.reshape(self.x_train,(len(self.x_train),self.cols))
    self.y_train = np.reshape(self.y_train,(len(self.y_train),1))
    self.x_test = np.reshape(self.x_test,(len(self.x_test),self.cols))
    self.y_test = np.reshape(self.y_test,(len(self.y_test),1))
    self.model.fit(self.x_train, self.y_train, batch_size = self.batch_size, epochs = self.epochs, validation_data = (self.x_test, self.y_test))

  def accurate():
    self.score, self.acc = self.model.evaluate(self.x_test, self.y_test, batch_size = self.batch_size)

  def load(self, directory):
    labels = []
    data = []
    for folder in os.listdir(directory):
      index = self.read_file(directory + "/" + folder + "/" + "index.txt")
      for file in index:
        frequency = defaultdict(int)
        file_path = directory + "/" + folder + "/" + "opcode/" + file + ".txt"
        opcodes = self.read_file(file_path)
        op = {el:0 for el in self.unique_opcodes}
        for val in opcodes:
          frequency[val] += 1
        for words in self.unique_opcodes:
          op[words] = frequency[words]
        data = data + [op.values()]
        labels = labels + [self.class_value(folder)]
    return data, labels
 

  def get_direccionary(self):
    train_unique_opcodes = self.load_files(self.train_data_set_directory)
    test_unique_opcodes = self.load_files(self.test_data_set_directory)
    self.unique_opcodes = list(set(train_unique_opcodes + test_unique_opcodes))
    self.cols = len(self.unique_opcodes)

  def set_classes(self):
    self.classes = self.read_file(self.classes_directory)

  def class_value(self, name):
    return self.classes.index(name)

  def load_files(self, directory):
    opcodes_vocabulary = []
    for folder in os.listdir(directory):
      index = self.read_file(directory + "/" + folder + "/" + "index.txt")
      for file in index:
        file_path = directory + "/" + folder + "/" + "opcode/" + file + ".txt"
        opcodes = self.read_file(file_path)
        opcodes_vocabulary = opcodes_vocabulary + list(set(opcodes))
    return opcodes_vocabulary

  def read_file(self, file_name):
    lines = [line.rstrip('\n') for line in open(file_name)]
    return lines

